\section{Re-Pairing Strategies}

We can now begin to discuss strategies for playing the re-pairing game. By strategy, we'll refer to a set of rules that we can follow to generate a sequence of moves which will always yield $\varepsilon_n$. We'll give algorithmic descriptions for each strategy that we intend to implement in the web application.

\subsection{Simple}
A \textbf{simple} re-pairing is one where every move pairs up matching brackets from the original Dyck word \cite{chistikov2020re}. 

Equivalently, for a Dyck word $\sigma$ and left bracket at index $l_i$, the right bracket $r_i$ is paired with $l_i$ in a simple re-pairing if $r_i$ is the smallest index such that $h_\sigma(l_i-1) = h_\sigma(r_i)$.

We notice that for any given Dyck word, there are many possible simple strategies; the idea of a "simple" strategy does not tell us about the ordering of the moves, just the property that each move has. We have also previously seen that the order matters greatly when attempting to minimise the width property.

We'll describe a simple strategy as follows. Given any Dyck word, we already have a naturally existing pairing, namely the pairs of matching brackets. We'll pair moves in the order of index of their leftmost matching bracket, taking the leftmost one to be paired first. This means for two moves $(l_i, r_i)$ and $(l_j, r_j)$, if $l_i < l_j$ then we perform $(l_i, r_i)$ first.

For example, suppose we wanted to re-pair the Dyck word \texttt{(()())(())} using this strategy. The re-pairing would be as follows:
\null
\begin{center}
    \texttt{(()())(())}\\
    \texttt{\string_()()\string_(())}\\
    \texttt{\string_\string_\string_()\string_(())}\\
    \texttt{\string_\string_\string_\string_\string_\string_(())}\\
    \texttt{\string_\string_\string_\string_\string_\string_\string_()\string_}\\
    \texttt{\string_\string_\string_\string_\string_\string_\string_\string_\string_\string_}
\end{center}
\null

\subsection{Greedy}
In a sense, the previous simple strategy we described was a greedy one, since we always take the leftmost bracket to pair each time. However, we could potentially do better. We make a simple observation to start with.
\begin{observation}
    If a word $\sigma$ is a Dyck prime, then it is of the form \texttt{($\sigma'$)}, where $\sigma'$ is another Dyck word.
\end{observation}
This means that we can repeatedly pair up the outermost brackets until the word is no longer prime before we need to use more complicated ideas.

In fact, we notice that we can define every width 1 word as follows.
\begin{observation}
    Let $\sigma = \texttt{()}$. Then every width 1 word can be generated by repeatedly applying one of the following:
    \begin{enumerate}
        \item $\sigma \rightarrow$ \texttt{($\sigma$)}
        \item $\sigma \rightarrow$ \texttt{()$\sigma$}
        \item $\sigma \rightarrow$ \texttt{$\sigma$()}
    \end{enumerate}
\end{observation}
\begin{proof}
    Every complete Dyck word starts off with width 1. From here, the only way we can maintain this width during a re-pairing is by making moves which do not increase the width. There are only 3 such moves:
    \begin{enumerate}
        \item Given \texttt{($\sigma$)}, pair up the outermost brackets.
        \item Given \texttt{()$\sigma$}, pair up the \texttt{()} on the left.
        \item Given \texttt{$\sigma$()}, pair up the \texttt{()} on the right.
    \end{enumerate}
    This concludes the proof.
\end{proof}

The first thing we notice from this is that pairing from the outside seems like a good idea.
What this also tells us is that a word of width 2 cannot be of the length 6; every word of length 6 can trivially be derived by applying the above 3 rules in some order. The first word of width 2 we then see must be \texttt{(())(())} as we cannot obtain it from the above rules.

\begin{corollary}
    The smallest Dyck word of width 2 is of length 8.
\end{corollary}

Using our observation on generating width 1 words, we see that applying the rules 1, 3, and 1 in that order on $\sigma$ gives us \texttt{((())())}. However, if we apply our previous simple strategy to it, we get a width 2 re-pairing:

\null
\begin{center}
    \texttt{((())())}\\
    \texttt{\string_(())()\string_}\\
    \texttt{\string_\string_()\string_()\string_}\\
    \texttt{\string_\string_\string_\string_\string_()\string_}\\
    \texttt{\string_\string_\string_\string_\string_\string_\string_\string_}\\
\end{center}
\null

It is clear that on the second move, we should have performed the move $(6,7)$, so the direction we pair from the outside should also vary depending on the context. 

From this we get an idea for an strategy; we will be greedy on the width of the outermost Dyck primes. To expand on this, given any Dyck word $\sigma$, it must either be prime or composite. If it is prime, remove its outermost brackets. If it is composite, we can write it as $A\sigma'B$, where A and B are Dyck primes, and $\sigma'$ is some Dyck word (it may be an empty string). Then we re-pair A or B completely depending on which has the lower width. 
However, from our previous example, we saw that even though \texttt{(())} and \texttt{()} would have the same width to re-pair, picking \texttt{()} to re-pair first is the better choice. We hypothesise this might be due to a shorter length.
So if A and B have the same width to re-pair, pick from whichever had the smaller length. If these are the same, the choice is arbitrary. 

Applying this strategy on the example we gave earlier yields a re-pairing of width 1.

% \subsection{Non-Simple}
% Conversely, a \textbf{non-simple} re-pairing is one where there is at least one move (note this means there would be at least two such moves) which do not pair up matching brackets. Equivalently, it is a re-pairing strategy that is not simple. 

% \subsubsection{Dyck words for complete binary trees}
% The paper upon which this project is based introduces a special type of Dyck words $Z(n)$ that can be associated with complete binary trees of height $n-1$. The definition uses the convention that $+ = $\texttt{(} and $- = $\texttt{)}.
% \begin{definition}[\cite{chistikov2020re}]
%     Let $Z(1) = +-$. We define $Z(n+1) = +Z(n)Z(n)-$. 
% \end{definition}
% The paper then shows that for any $Z(n)$, $width(Z(n)) = 2^{\bigO\sqrt{\log n})}$. It does so by introducing a non-simple recursive strategy for re-pairing words of the form $Z(n)$.
