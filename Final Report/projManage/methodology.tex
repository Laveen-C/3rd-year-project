\section{Methodology}

\subsection{Development Methodology}
This project used the Agile methodology, as the goals and limitations of the project aligned closely with the principles of Agile \cite{agilePrinciples}:
\begin{itemize}
    \item Creating functional software was of a higher priority than comprehensive documentation. The faster that the software was made functional, the more time could be devoted to its refinement. Given that the author was also new to writing web applications and many of the libraries chosen at the start of this project, making such refinements proved to have a steeper learning curve.
    \item Responding to changes in requirements was of a higher priority than a strict plan and implementation. Throughout the process of absorbing the seminal work \cite{chistikov2020re}, more elegant and useful ideas arose and became the clear option to implement over the current option.
\end{itemize}

% With the initial approach of a local Python app in mind, we begun with writing the strategies as algorithms in Python. However, when the approach was changed 

Note that the \hyperref[softwareReqs]{software requirements} were written in such a way that each one could mostly be handled sequentially, without needing anything that hadn't been met yet. This is roughly the approach taken during development and testing. 

\subsection{Testing Methodology}
As development was done in an Agile manner, it made sense for all testing to be manual, since the functionality of the software was rapidly changing as it was being developed. This meant writing automated tests each time new functionality was required would have been more time-consuming than manual tests. The theoretical nature of the game for which the web application was designed also made manual testing a suitable option; as long as definitions were translated correctly into code and certain edge cases were verified, the software could be expected to perform as required.

All testing was done using a combination of unit testing, incremental integration testing, and requirement-based testing. We elaborate on this process below:

\subsubsection{Unit Testing}
During the development, each of the \hyperref[softwareReqs]{software requirements} was decomposed into smaller functions and subgoals needed to fulfill their relevant requirements. This naturally leads into unit testing; we treated each function as its own unit, and tested it according to the expected functionality. 

For example, to ensure a Dyck word is valid and provide error messages if necessary, we break this down into multiple units as follows:
\begin{enumerate}
    \item A function for the frontend to call and receive data from
    \item A function to check the input against the \hyperref[def:seqDyck]{definition of a Dyck word}, and return a yes or no answer along with a relevant error message
    \item Logic to check if an error was returned
    \item Logic to display the error or the input depending on the result
\end{enumerate}

We then write a function (or in some cases with the frontend, a portion of code or a new state variable) and test each of them work as expected. 

As previously mentioned, by using Flask as the framework of choice for the backend, the Python code required minimal modification to allow functions to serve requests. This made unit testing much easier to perform. 

\subsubsection{Incremental Testing}
After