\chapter{Introduction}

We start with a simple one-player game. Take any Dyck word (a balanced sequence of opening and closing brackets), for example:

\null
\begin{center}
    \texttt{\large (()())}
\end{center}
\null

A \textbf{move} in this game consists of pairing any opening bracket with any closing bracket to its right, and replacing the two with a blank space/gap (denoted with the \texttt{\string_} symbol). This process is repeated until there are no more brackets to pair up, resulting in the empty string, and the sequence of moves made is called a \textbf{re-pairing}. An example of a re-pairing is as follows:

\null
\begin{center}
    \texttt{\large (()())}\\
    \texttt{\large (\string_)(\string_)}\\
    \texttt{\large \string_\string_\string_(\string_)}\\
    \texttt{\large \string_\string_\string_\string_\string_\string_}\\
\end{center}
\null

Note that our first move pairs up two brackets that are not matched to each other in the initial word. We allow such moves in a re-pairing. 

Finding any re-pairing following these rules is a trivial task, but we want to measure how good a re-pairing is. For this we introduce a property called the \textbf{width}, defined as the maximum number of non-empty segments of brackets seen during the re-pairing. We can see that the previous re-pairing had width 2. A natural question then arises; can we obtain a re-pairing with a smaller width? The answer for this particular string is yes, and such a re-pairing is shown below:

\null
\begin{center}
    \texttt{\large (()())}\\
    \texttt{\large \string_()()\string_}\\
    \texttt{\large \string_()\string_\string_\string_}\\
    \texttt{\large \string_\string_\string_\string_\string_\string_}\\
\end{center}
\null

Here we see this re-pairing has width 1. Our goal is to try and minimise this width as much as possible. 


\section{Objectives}

This project aims to take both a theoretical and practical approach to this game. We split the project into two parts; a literature review and software development.

The literature review aims to assess the current knowledge available on the game by understanding and expanding on the relevant background knowledge, context and results. This will also help gain a more intuitive grasp on the topic. 

The software development aspect aims to implement strategies in the re-pairing game to allow for visualisation and experimentation. A subgoal of this is to attack the goal of minimising width with software, by analysing certain strategies and subcases of Dyck words. More specifically, the objectives of the project can be outlined as follows:

\begin{enumerate}
    \item An introduction to the relevant definitions and content to lay out background knowledge.
    \item Expanding on and providing potential novel insights on well established results.
    \item Establishing the research landscape on the re-pairing game and relevant topics.
    \item Creating software to demonstrate re-pairing strategies from literature and allow manual experimentation on Dyck word re-pairings.
    \item Using software to analyse subcases of Dyck words and exhaustively find their width in an attempt to pin down the formula of a general Dyck word.
\end{enumerate}

\section{Related work}
This project builds on the work from Chistikov and Vyalyi \cite{chistikov2020re}, whose paper serves as a basis for this project. The paper introduces this game as a way to prove a lower bound on translating one-counter automata (OCA) into Parikh-equivalent nondeterministic finite automata (NFA). It provides lower bounds on the width for simple and non-simple re-pairings, which is then used to prove lower bounds on these translations.

Due to the specialised nature of this game's origins, there are no other works on this game at the time of writing.